# 为什么我们需要TCP（二）

在为什么我们需要TCP（一）中我们讨论了TCP是如何保证连接是可靠的，但是如何建立一个连接并没有讨论。这次继续这个问题进行思考。

#### 建立连接要面对的问题

现在有A、B两台机器需要建立一个的连接，A尝试着向B发出一个请求连接的信号。想象一下都有什么可能发生？
1. B收到了请求，A、B建立起了一个连接，A向B发送字节流
2. B没收到，A、B没有建立起连接，但是A并不知道B没收到，A向B发送字节流，结果全部石沉大海。

怎么解决这个问题？很简单，如果B收到了回复给A一个确认的信号，A收到回复才会继续发送字节流。但是如果过了很久B还没有回复呢？A再发送一次连接请求就好了。问题看似得到了解决，但是又引入了新的问题。考虑一下A=>B,B=>A的连接模式下都可能发生什么？
1. B收到了请求，回复给A，A、B建立起了一个连接，A向B发送字节流
2. B没收到了请求，A过了很久没收到请求，又重新发起了一次请求，这次B收到并回复了，A、B建立起了连接
3. B没收到了请求，A过了很久没收到请求，又重新发起了一次请求，然后B收到了第一次的请求，B和很久之前的A建立了连接，然后。。。A、B都懵逼了

怎么办？这时候我们就需要第三次确认了，B在回复的时候告诉A我接收到的是第n号连接，A就可以据此判断这是不是历史连接并决定是否建立这次连接。


#### 用什么来交流

在之前的内容中我们模拟了一系列情况用于分析为何需要三次确认（即三次握手），但是模糊掉了一些内容：

1. A向B发送了些什么
    
    A首先向B发送了一个包,告诉B“请求创建一个连接”。包含着CTL=SYN(表示synchronous建立连接)和一个随机的seq值，比如seq=n（还记么？就是上一篇提到的，用于给包裹排序的标签）。

2. B返回了什么

    B会返回一个CTL=ACK（表示acknowledgement 确认）返回一个ack=n+1(即接收到的seq+1)。同时生成一个新的seq=m的随机值

3. A如何根据B的返回判断B收到的是不是历史连接
    
    A收到B返回的ack就可以对比是否等于自己最近发送出去的seq+1，相等则认为这次连接是有效的，不相等则认为B收到了历史连接，发送信息告诉B这是无效的。


#### 总结

- 三次握手保证了我们创建的连接是有效的（不会重复建立历史连接）
- 三次握手初始化了服务器和客户端各自的seq字段，初始化了客户端的ack字段

由于网络的承载能力是有限的，如果把所有的数据包都一股脑儿的塞到网络中就会导致拥堵，如果网络情况很好，但是接收方的能力有限，又会把接收方的撑坏。因此TCP又设计了不同的方法来解决这些问题，下次继续讨论。