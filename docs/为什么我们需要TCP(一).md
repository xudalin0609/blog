# 为什么我们需要 TCP（三）

之前我们讨论了问什么需要 TCP 和 TCP 是如何创建有效连接的，接下来我们继续思考一下，TCP 的连接是如何安全的断开的。要回答这个问题，我们首先要知道，为什么 TCP 的断开需要解决什么问题。

#### 场景模拟

在 A、B 之间已经创建了一个有效的 TCP 连接，然后，A 决定断开这次连接。

- 情况 1：A 单方面解除了此次连接，不再接受 B 传来的报文段了。
  很容易猜到结果，B 仍在傻傻的发送报文段，A 却没有接到，于是部分内容丢失了，连接不安全了。为了解决这个问题，A 需要告诉 B，“别发了别发了，我们结束了”。

- 情况 2：A 告诉 B，“我要断开连接了，你别发信息了”。但是**网络是不稳定的**，所以 B 没收到。A 过了一会没得到 B 的答复，就又发了一次，“我要断开连接了，你别发信息了”。这次 B 收到了，于是和 A 说，“我知道了，不过你得等会儿哈，我还有点儿东西没发完。”过了一会儿，B 的东西都发完了，就主动和 A 说，“得嘞，都发完了，再见！”。这时 B 就可以断开了么？记住，**网络是不稳定的**，所以如果此时 B 就断开了，那出现了报文段丢失就没办法了，所以 B 还得等着，等到确认 A 所有内容都收到了才能断开。

- 情况 3：A 告诉 B，“我要断开连接了，你别发信息了”。B 和 A 说，“我知道了，不过你得等会哈，我还有点儿东西没发完。”过了一会儿，B 主动和 A 说“得嘞，都发完了，等你都收到了，我就断开了”。说完，B 就开始等着 A 的回复了。A 每收到一个报文段就和 B 发送一个 ack，当 B 发现 A 收到最后一个报文段了，B 就安心的断开了。（如果发现报文段丢失则会重发）。A 等了一阵儿，也发现不会再收到报文段了，就也断开了连接。至此连接结束。

以上就是四次挥手的基本流程了。概括一下。

1. A 发起的断开连接的请求。
2. B 向 A 发送“确认收到”
3. 过了一会儿，B 向 A 发送“数据包发送完成”
4. B 收到了 A 的全部接收确认后断开连接，A 过了一段儿时间后断开连接。

#### 四次挥手真的是安全的么？

以下内容只是我的猜测，没有阅读到相关文档，待确认

假设 1：现在的网络状态极差

假设 2：现在处于断开连接的第四步(B 收到了 A 的全部接收确认后断开连接，A 过了一段儿时间后断开连接。)

<del>如果 B 向 A 发送的报文段全部丢失，当过了一段时间后，A 会自动关闭连接，这是不是意味着部分报文段丢失了呢？ </del>

这里我出现了一个很愚蠢的错误，B只有接收到A的全部ack之后才会断开连接，这表示A并没有丢失掉报文段。那么既然A已经接收到了全部的报文段，又为什么要等一会儿在断开连接呢？

原因一：
    历史的报文段是有可能延迟抵达的，如果A没有等待直接关闭了连接，当迷路的报文段抵达时有可能会被其他连接错误的处理。所以A需要等待一会儿(这个时间为2WSL)，确保历史的报文段都抵达了。（如果报文段的传输时间超过2WSL会被废弃）

原因二：
    

#### 总结

- 为了连接的安全断开，断开的发起方需要确认所有的报文都被接受完毕
- 断开的被动方接收到断开的请求后，需要等待所有报文发送完毕后主动通知发起方

以上只是四次挥手的基本流程，具体会有一些关于标志字段的细节和可调参数，后续会继续完善本文档。
